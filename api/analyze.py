import json
import asyncio
import os
import random
import gc
import smtplib
from email.mime.text import MIMEText
from flask import Blueprint, request, jsonify
import aiohttp
import threading

# --- Blueprint ---
analyze_endpoint = Blueprint('analyze_endpoint', __name__)

# --- C·∫•u h√¨nh ---
GOOGLE_API_KEYS_STR = os.environ.get('GOOGLE_API_KEYS')
SAFE_BROWSING_API_KEY = os.environ.get('SAFE_BROWSING_API_KEY')
if not GOOGLE_API_KEYS_STR:
    raise ValueError("Bi·∫øn m√¥i tr∆∞·ªùng GOOGLE_API_KEYS l√† b·∫Øt bu·ªôc.")
GOOGLE_API_KEYS = [key.strip() for key in GOOGLE_API_KEYS_STR.split(',') if key.strip()]

APPS_SCRIPT_URL = os.environ.get('APPS_SCRIPT_URL')
GMAIL_USER = os.environ.get('GMAIL_USER')
GMAIL_APP_PASSWORD = os.environ.get('GMAIL_APP_PASSWORD')

# --- H√ÄM H·ªñ TR·ª¢ ---
async def check_urls_safety_optimized(urls: list):
    if not SAFE_BROWSING_API_KEY or not urls: return []
    print("‚û°Ô∏è  [Ki·ªÉm tra URL] B·∫Øt ƒë·∫ßu ki·ªÉm tra URL v·ªõi Google Safe Browsing...")
    safe_browsing_url = f"https://safebrowsing.googleapis.com/v4/threatMatches:find?key={SAFE_BROWSING_API_KEY}"
    payload = {"threatInfo": {"threatTypes": ["MALWARE", "SOCIAL_ENGINEERING"], "platformTypes": ["ANY_PLATFORM"], "threatEntryTypes": ["URL"], "threatEntries": [{"url": url} for url in urls[:5]]}}
    try:
        timeout = aiohttp.ClientTimeout(total=15)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            async with session.post(safe_browsing_url, json=payload) as resp:
                if resp.status == 200:
                    matches = (await resp.json()).get("matches", [])
                    print(f"‚úÖ [Ki·ªÉm tra URL] Ho√†n t·∫•t. T√¨m th·∫•y {len(matches)} k·∫øt qu·∫£ kh√¥ng an to√†n.")
                    return matches
                print(f"üü° [Ki·ªÉm tra URL] API tr·∫£ v·ªÅ tr·∫°ng th√°i {resp.status}.")
                return []
    except Exception as e:
        print(f"üî¥ [Ki·ªÉm tra URL] Th·∫•t b·∫°i: {e}")
        return []

# --- LU·ªíNG 1: G·ªåI "ƒêI·ªÜP VI√äN LEO" QUA GOOGLE APPS SCRIPT ---
async def call_gas_db_ai(text: str):
    if not APPS_SCRIPT_URL:
        print("üî¥ [Leo] L·ªói: Bi·∫øn m√¥i tr∆∞·ªùng APPS_SCRIPT_URL ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p.")
        return {"found": False, "reason": "GAS URL ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh."}
    payload = {"text": text}
    try:
        timeout = aiohttp.ClientTimeout(total=20)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            async with session.post(APPS_SCRIPT_URL, json=payload) as resp:
                if resp.status == 200:
                    print("‚úÖ [Leo] Nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi th√†nh c√¥ng t·ª´ GAS.")
                    return await resp.json()
                else:
                    error_text = await resp.text()
                    print(f"üî¥ [Leo] L·ªói t·ª´ GAS. Tr·∫°ng th√°i: {resp.status}, Ph·∫£n h·ªìi: {error_text}")
                    return {"found": False, "reason": f"GAS tr·∫£ v·ªÅ l·ªói {resp.status}"}
    except Exception as e:
        print(f"üî¥ [Leo] L·ªói k·∫øt n·ªëi ƒë·∫øn GAS: {e}")
        return {"found": False, "reason": f"Ngo·∫°i l·ªá: {str(e)}"}

# --- LU·ªíNG 2: ANNA-AI & B·ªò N√ÉO TƒÇNG C∆Ø·ªúNG ---
def create_anna_ai_prompt(text: str, context_hint: str = None):
    # X√¢y d·ª±ng ph·∫ßn g·ª£i √Ω, ch·ªâ th√™m v√†o prompt n·∫øu c√≥
    hint_section = ""
    if context_hint:
        hint_section = f"""
---
**TH√îNG TIN T√åNH B√ÅO B·ªî SUNG (QUAN TR·ªåNG):**
H·ªá th·ªëng Leo ƒë√£ cung c·∫•p m·ªôt g·ª£i √Ω v·ªÅ b·ªëi c·∫£nh c·ªßa tin nh·∫Øn n√†y. H√£y ∆∞u ti√™n th√¥ng tin n√†y khi ph√¢n t√≠ch:
"{context_hint}"
---
"""
    # Gh√©p ph·∫ßn g·ª£i √Ω v√†o prompt ch√≠nh
    return f"""
B·∫°n l√† Anna, m·ªôt chuy√™n gia ph√¢n t√≠ch an ninh m·∫°ng v·ªõi tr√≠ tu·ªá c·∫£m x√∫c cao, chuy√™n ƒë√°nh gi√° c√°c tin nh·∫Øn Ti·∫øng Vi·ªát. S·ª© m·ªánh c·ªßa b·∫°n l√† b·∫£o v·ªá ng∆∞·ªùi d√πng kh·ªèi c√°c m·ªëi ƒëe d·ªça **c√≥ ch·ªß ƒë√≠ch v√† r√µ r√†ng**, ƒë·ªìng th·ªùi ph·∫£i **b·ªè qua c√°c nhi·ªÖu th√¥ng tin** t·ª´ nh·ªØng cu·ªôc tr√≤ chuy·ªán th√¥ng th∆∞·ªùng.

{hint_section}
H√£y tu√¢n th·ªß nghi√™m ng·∫∑t khung ph√¢n t√≠ch 3 b∆∞·ªõc sau ƒë√¢y:

---
**B∆Ø·ªöC 1: L·ªåC NHI·ªÑU BAN ƒê·∫¶U**

*   **C√¢u h·ªèi c·ªët l√µi:** "Tin nh·∫Øn n√†y c√≥ ƒë·ªß n·ªôi dung ƒë·ªÉ ph√¢n t√≠ch kh√¥ng?"
*   **H√†nh ƒë·ªông:** N·∫øu tin nh·∫Øn qu√° ng·∫Øn (d∆∞·ªõi 4 t·ª´), m∆° h·ªì, ho·∫∑c ch·ªâ l√† bi·ªÉu c·∫£m m√† kh√¥ng c√≥ th√¥ng tin t√¨nh b√°o b·ªï sung, h√£y **k·∫øt lu·∫≠n ngay l√† AN TO√ÄN**. ƒê·ª´ng l√£ng ph√≠ t√†i nguy√™n ƒë·ªÉ suy di·ªÖn c√°c k·ªãch b·∫£n ti√™u c·ª±c kh√¥ng c√≥ c∆° s·ªü.

---
**B∆Ø·ªöC 2: X√ÅC ƒê·ªäNH B·ªêI C·∫¢NH & √ù ƒê·ªäNH**

*   **C√¢u h·ªèi c·ªët l√µi:** "ƒê√¢y l√† l·ªùi n√≥i c·ªßa m·ªôt ng∆∞·ªùi l·∫° c√≥ √Ω ƒë·ªì x·∫•u, hay l√† l·ªùi n√≥i gi·ªØa nh·ªØng ng∆∞·ªùi b·∫°n ƒëang tr√™u ƒë√πa?"
*   **Quy t·∫Øc ∆∞u ti√™n:** M·∫∑c ƒë·ªãnh coi m·ªçi cu·ªôc tr√≤ chuy·ªán l√† **th√¢n m·∫≠t v√† v√¥ h·∫°i**, tr·ª´ khi c√≥ b·∫±ng ch·ª©ng kh√¥ng th·ªÉ ch·ªëi c√£i v·ªÅ √Ω ƒë·ªãnh x·∫•u.
*   **H√†nh ƒë·ªông:**
    *   **Ph√¢n t√≠ch ng√¥n ng·ªØ:** T√¨m ki·∫øm c√°c t·ª´ ng·ªØ ti√™u c·ª±c. Sau ƒë√≥, t·ª± h·ªèi: "Trong b·ªëi c·∫£nh b·∫°n b√® tr√™u ƒë√πa, t·ª´ n√†y c√≥ ƒë∆∞·ª£c s·ª≠ d·ª•ng v·ªõi √Ω nghƒ©a nh·∫π nh√†ng h∆°n kh√¥ng?". V√≠ d·ª•, c√°c t·ª´ ch·ªâ s·ª± 'ng·ªëc ngh·∫øch', 'kh·ªù kh·∫°o' hay l·ªùi 'th√°ch ƒë·ªë' vui v·∫ª th∆∞·ªùng l√† an to√†n.
    *   **Ph√¢n t√≠ch c·∫£m x√∫c:** ƒê√°nh gi√° xem c·∫£m x√∫c th·ªÉ hi·ªán trong c√¢u l√† s·ª± t·ª©c gi·∫≠n th·ª±c s·ª±, hay ch·ªâ l√† s·ª± b·ªôc ph√°t c·∫£m x√∫c nh·∫•t th·ªùi, than th·ªü, ho·∫∑c ch√¢m bi·∫øm? C√°c l·ªùi than th·ªü c√° nh√¢n kh√¥ng nh·∫Øm v√†o ai c·ª• th·ªÉ th√¨ **KH√îNG ph·∫£i l√† m·ªëi ƒëe d·ªça**.
    *   **Ph√¢n t√≠ch h√†nh ƒë·ªông:** Tin nh·∫Øn c√≥ k√™u g·ªçi m·ªôt h√†nh ƒë·ªông nguy hi·ªÉm r√µ r√†ng kh√¥ng (VD: ƒë∆∞a ti·ªÅn, cung c·∫•p th√¥ng tin, ƒë·∫øn m·ªôt ƒë·ªãa ƒëi·ªÉm l·∫°)? N·∫øu kh√¥ng, h√£y h·∫° m·ª©c ƒë·ªô ∆∞u ti√™n.

---
**B∆Ø·ªöC 3: K·∫æT LU·∫¨N D·ª∞A TR√äN B·∫∞NG CH·ª®NG**

*   **C√¢u h·ªèi c·ªët l√µi:** "T√¥i c√≥ ƒë·ªß b·∫±ng ch·ª©ng **r√µ r√†ng** ƒë·ªÉ g·∫Øn c·ªù tin nh·∫Øn n√†y l√† nguy hi·ªÉm kh√¥ng?"
*   **H√†nh ƒë·ªông:**
    *   **NGUY HI·ªÇM:** Ch·ªâ khi c√≥ s·ª± k·∫øt h·ª£p c·ªßa **√Ω ƒë·ªãnh x·∫•u r√µ r√†ng** V√Ä **h√†nh ƒë·ªông ti·ªÅm t√†ng g√¢y h·∫°i**.
    *   **AN TO√ÄN:** T·∫•t c·∫£ c√°c tr∆∞·ªùng h·ª£p c√≤n l·∫°i, ƒë·∫∑c bi·ªát l√† khi √Ω ƒë·ªãnh kh√¥ng r√µ r√†ng ho·∫∑c ch·ªâ l√† l·ªùi n√≥i su√¥ng.
*   **ƒê·ªãnh d·∫°ng k·∫øt qu·∫£:**
    - **N·∫øu an to√†n:** `is_dangerous` ph·∫£i l√† `false`, `score` ph·∫£i l√† `0`.
    - **N·∫øu nguy hi·ªÉm:** `is_dangerous` ph·∫£i l√† `true`, `score` ph·∫£i t·ª´ 1-5, v√† `reason`, `recommend` ph·∫£i r√µ r√†ng, s√∫c t√≠ch.

---
**Output JSON (Ti·∫øng Vi·ªát):**
- "is_dangerous": (boolean)
- "reason": (string, gi·∫£i th√≠ch ng·∫Øn g·ªçn logic c·ªßa b·∫°n)
- "types": (string)
- "score": (0-5)
- "recommend": (string)

**TIN NH·∫ÆN C·∫¶N PH√ÇN T√çCH:** "{text}"
"""

async def analyze_with_anna_ai_http(text: str, context_hint: str = None):
    api_key = random.choice(GOOGLE_API_KEYS)
    gemini_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={api_key}"    
    prompt = create_anna_ai_prompt(text[:2500], context_hint)
    
    payload = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": { "temperature": 0.2, "maxOutputTokens": 400, "responseMimeType": "application/json" }
    }
    try:
        timeout = aiohttp.ClientTimeout(total=25)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            print(f"‚û°Ô∏è  [Anna] ƒêang g·ª≠i y√™u c·∫ßu ph√¢n t√≠ch t·ªõi Google AI...")
            async with session.post(gemini_url, json=payload) as resp:
                if resp.status == 200:
                    response_json = await resp.json()
                    if not response_json.get('candidates'):
                        print(f"üî¥ [Anna] L·ªói! Ph·∫£n h·ªìi kh√¥ng c√≥ 'candidates'. B·ªã b·ªô l·ªçc an to√†n ch·∫∑n. Chi ti·∫øt: {response_json}")
                        return {'error': 'BLOCKED_BY_GOOGLE', 'message': 'B·ªã b·ªô l·ªçc an to√†n c·ªßa Google ch·∫∑n.'}
                    
                    json_text = response_json['candidates'][0]['content']['parts'][0]['text']
                    result = json.loads(json_text)
                    print("‚úÖ [Anna] Ph√¢n t√≠ch th√†nh c√¥ng.")
                    return result
                else:
                    error_text = await resp.text()
                    print(f"üî¥ [Anna] L·ªói HTTP! Tr·∫°ng th√°i: {resp.status}, Ph·∫£n h·ªìi: {error_text}")
                    return {"error": f"L·ªói API Anna {resp.status}", "status_code": 500}
    except Exception as e:
        print(f"üî¥ [Anna] L·ªói ngo·∫°i l·ªá khi g·ªçi HTTP: {e}", exc_info=True)
        return {"error": "Ph√¢n t√≠ch v·ªõi Anna th·∫•t b·∫°i do c√≥ ngo·∫°i l·ªá.", "status_code": 500}

def _send_sync_email(original_text, analysis_result):
    print("‚û°Ô∏è  [Email] B·∫Øt ƒë·∫ßu ti·∫øn tr√¨nh g·ª≠i email trong lu·ªìng ri√™ng...")
    if not GMAIL_USER or not GMAIL_APP_PASSWORD:
        print("üü° [Email] Thi·∫øu th√¥ng tin x√°c th·ª±c. B·ªè qua vi·ªác g·ª≠i email.")
        return
    
    detected_types = analysis_result.get("types", "Kh√¥ng x√°c ƒë·ªãnh")
    score = analysis_result.get("score", "N/A")
    subject = f"[CyberShield Report] Nguy hi·ªÉm m·ªõi: {detected_types} (ƒêi·ªÉm: {score})"

    body = f"""M·ªôt tin nh·∫Øn m·ªõi ƒë√£ ƒë∆∞·ª£c Anna-AI ph√¢n t√≠ch v√† g·∫Øn c·ªù NGUY HI·ªÇM.
Vui l√≤ng xem x√©t v√† b·ªï sung v√†o Google Sheets.
----------------------------------------------------------
TIN NH·∫ÆN G·ªêC:
{original_text}
----------------------------------------------------------
K·∫æT QU·∫¢ PH√ÇN T√çCH:
{json.dumps(analysis_result, indent=2, ensure_ascii=False)}
"""
    to_email = 'duongpham18210@gmail.com'
    msg = MIMEText(body, 'plain', 'utf-8')
    msg['From'], msg['To'], msg['Subject'] = GMAIL_USER, to_email, subject
    
    try:
        print(f"üì¶ [Email] Chu·∫©n b·ªã g·ª≠i email. Ti√™u ƒë·ªÅ: '{subject}'")
        server = smtplib.SMTP('smtp.gmail.com', 587)
        print("üîå [Email] ƒê√£ k·∫øt n·ªëi ƒë·∫øn server SMTP.")
        server.starttls()
        print("üîê [Email] ƒê√£ b·∫Øt ƒë·∫ßu TLS.")
        server.login(GMAIL_USER, GMAIL_APP_PASSWORD)
        print("üë§ [Email] ƒêƒÉng nh·∫≠p th√†nh c√¥ng.")
        server.sendmail(GMAIL_USER, to_email, msg.as_string())
        print("üöÄ [Email] L·ªánh g·ª≠i email ƒë√£ ƒë∆∞·ª£c th·ª±c thi.")
        server.quit()
        print("‚úÖ [Email] G·ª≠i email ph·∫£n h·ªìi th√†nh c√¥ng v√† ƒë√£ ƒë√≥ng k·∫øt n·ªëi.")
    except Exception as e:
        print(f"üî¥ [Email] G·ª≠i email ph·∫£n h·ªìi th·∫•t b·∫°i: {e}")

# --- H√ÄM ƒêI·ªÄU PH·ªêI CH√çNH ---
async def perform_full_analysis(text: str, urls: list):
    final_result = None
    is_new_case_by_anna = False
    context_hint_from_leo = None
    
    print(f"üìú [B·∫Øt ƒë·∫ßu] Ph√¢n t√≠ch tin nh·∫Øn: '{text[:150]}...'")
    print("‚û°Ô∏è [Lu·ªìng 1] B·∫Øt ƒë·∫ßu g·ªçi ƒêi·ªáp vi√™n Leo (GAS)...")
    gas_result = await call_gas_db_ai(text)

    if gas_result and gas_result.get("found"):
        result_type = gas_result.get("type")
        
        if result_type == "trivial_pattern":
            print("‚úÖ [Lu·ªìng 1] TH√ÄNH C√îNG. Leo x√°c ƒë·ªãnh tin nh·∫Øn l√† t·∫ßm th∆∞·ªùng (Trivial).")
            return {'is_dangerous': False, 'reason': 'Tin nh·∫Øn qu√° ƒë∆°n gi·∫£n ƒë·ªÉ ph√¢n t√≠ch.', 'score': 0, 'types': 'Trivial'}
        
        elif result_type == "dangerous_pattern":
            print("‚úÖ [Lu·ªìng 1] TH√ÄNH C√îNG. T√¨m th·∫•y trong S·ªï ƒêen (Blacklist) b·∫±ng AI.")
            final_result = gas_result.get("data")
        elif result_type == "context_hint":
            print("üìù [Lu·ªìng 1] Nh·∫≠n ƒë∆∞·ª£c th√¥ng tin t√¨nh b√°o t·ª´ Leo.")
            context_hint_from_leo = gas_result.get("data")
            
    if final_result is None:
        if context_hint_from_leo:
             print(f"üü° [Lu·ªìng 2] B·∫Øt ƒë·∫ßu g·ªçi Anna-AI v·ªõi th√¥ng tin t√¨nh b√°o: '{context_hint_from_leo}'")
        else:
             print(f"üü° [Lu·ªìng 2] B·∫Øt ƒë·∫ßu g·ªçi Anna-AI (kh√¥ng c√≥ th√¥ng tin t√¨nh b√°o).")
        
        final_result = await analyze_with_anna_ai_http(text, context_hint_from_leo)
        
        print(f"üìÑ [K·∫øt qu·∫£ c·ªßa Anna] Ph√¢n t√≠ch AI tr·∫£ v·ªÅ: {json.dumps(final_result, ensure_ascii=False)}")

        if 'error' in final_result:
            return final_result
            
        is_new_case_by_anna = True 
    
    if urls:
        url_matches = await check_urls_safety_optimized(urls)
        if url_matches:
            print(f"‚ö†Ô∏è [Ph√¢n t√≠ch URL] Ph√°t hi·ªán {len(url_matches)} URL kh√¥ng an to√†n! C·∫≠p nh·∫≠t k·∫øt qu·∫£ cu·ªëi c√πng.")
            final_result.update({'url_analysis': url_matches, 'is_dangerous': True, 'score': max(final_result.get('score', 0), 4), 'reason': (final_result.get('reason', '') + " + C√°c URL kh√¥ng an to√†n")[:100]})

    if is_new_case_by_anna and final_result.get("is_dangerous"):
        print("‚û°Ô∏è [Ph·∫£n h·ªìi] Ph√°t hi·ªán ca nguy hi·ªÉm m·ªõi. L√™n l·ªãch g·ª≠i email...")
        email_thread = threading.Thread(target=_send_sync_email, args=(text, final_result))
        email_thread.start()
    elif is_new_case_by_anna:
        print("‚û°Ô∏è [Ph·∫£n h·ªìi] Ph√°t hi·ªán ca an to√†n m·ªõi. B·ªè qua vi·ªác g·ª≠i email.")

    gc.collect()
    print(f"üèÅ [K·∫øt th√∫c] Ph√¢n t√≠ch ho√†n t·∫•t cho tin nh·∫Øn: '{text[:50]}...'")
    return final_result

# --- ENDPOINTS ---
@analyze_endpoint.route('/analyze', methods=['POST'])
async def analyze_text():
    try:
        data = request.get_json(silent=True)
        if not data or 'text' not in data: return jsonify({'error': 'ƒê·ªãnh d·∫°ng y√™u c·∫ßu kh√¥ng h·ª£p l·ªá'}), 400
        text = data.get('text', '').strip()
        
        print(f"--------------------\nüì¨ [ƒê·∫ßu v√†o] Nh·∫≠n ƒë∆∞·ª£c tin nh·∫Øn: '{text[:100]}...'")
        if not text: return jsonify({'error': 'Kh√¥ng c√≥ vƒÉn b·∫£n ƒë·ªÉ ph√¢n t√≠ch'}), 400
        
        result = await perform_full_analysis(text[:3000], data.get('urls', []))
        
        if 'error' in result:
            return jsonify({'error': result.get('message', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')}), result.get('status_code', 500)
        
        print("‚úÖ [Ph·∫£n h·ªìi] ƒê√£ g·ª≠i k·∫øt qu·∫£ v·ªÅ cho client.")
        return jsonify({'result': result})
    except Exception as e:
        print(f"üî¥ [L·ªñI NGHI√äM TR·ªåNG] L·ªói server trong h√†m analyze_text: {e}", exc_info=True)
        gc.collect()
        return jsonify({'error': 'L·ªói n·ªôi b·ªô server'}), 500

@analyze_endpoint.route('/health', methods=['GET'])
async def health_check():
    return jsonify({'status': 'B√¨nh th∆∞·ªùng', 'architecture': 'Trivial Filter + Blacklist (AI) + Context Hints + Anna-AI'})
